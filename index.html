<!DOCTYPE html>

<html>
<head>
<meta name="description" content="Sokobond JS Chemical Zen">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Sokobond JS - Chemical Zen</title>
  
<style>    
  
#board{
  
  }

table {
  border-spacing: 0px;
}
  
td {
  margin: 0px;
  padding: 0px;  
  border-width:0px;
}  
  
svg{
 display: block;       
}
  
.me{
  text-shadow: 2px 2px 4px blue;
}
 
.vacuum{
  width: 50px;
  height: 50px;
}
  
.bond_vert{
  -text-align: center; 
  width: 5px; 
  height: 50px;
  }

.bond_horiz{
  -text-align: center;
  width: 50px;
  height: 5px;
  }
  
.hyperspace{
  text-align: center;  
  width: 5px;  
  height: 5px;   
  }
  
.wall{
  background-color: CornflowerBlue;
}
  
.atom{
}
  
</style>
</head>

<body  ONKEYUP="Key_Input(event.keyCode);">

<div id=board></div>

<br>
<form action="#">
<input type="button" value="How To Play" onclick='alert(how_to_play);'>
</form>
  
<p></p>
Build Your Own Puzzle:
<br>  
<textarea id="input_area" rows="4" cols="50">
8_8
W0W0W0W0W0W0W0W0W
00000000000000000
W000h000h000h000W
00000000000000000
W00000H000H00000W
00000000000000000
W0W0W0000000W0W0W
00000000000000000
0000W0O0h0O0W0000
00000000000000000
W0W0W0000000W0W0W
00000000000000000
W00000H000H00000W
00000000000000000
W000h000h000h000W
00000000000000000
W0W0W0W0W0W0W0W0W
</textarea>
  
<form action="#">
<input type="button" value="Refresh Puzzle" onclick='Build_Puzzle(document.getElementById("input_area").value);'>

<input type="button" value="How to build a puzzle" onclick='alert(building_a_puzzle);'>

</form>

<script>  
//global vars ----------------------
var error_msg = '';
var input_string;
var empty_chars = ['0']; 
var atom_chars = ['H','h','O','C','N'];
var wall_chars = ['W'];
var modifier_chars = ['+','-','.'];
var bond_chars = ['1','2','3','4'];
var validate_board_pos = {};  //note keys match state/class so we can do build board error checking
validate_board_pos['hyperspace'] = empty_chars.concat(modifier_chars);
validate_board_pos['vacuum'] = empty_chars.concat(atom_chars,wall_chars);
validate_board_pos['bond_vert'] = empty_chars.concat(bond_chars);
validate_board_pos['bond_horiz'] = empty_chars.concat(bond_chars);    
var direction = {
 'N' : { 'x':0 , 'y':-1  },
 'S' : { 'x':0 , 'y':1  },
 'E' : { 'x':1 , 'y':0  },
 'W' : { 'x':-1 , 'y':0  }  
};
 
var x_y_me='';
var board = {}; //x,y,can_be=[empty,wall,atom,bond,bond_modifier], is_a , obj (atom,bond,wall..) , class
//allows us to save JSON.stringify(board) then easily rebuild each object on board.  
var move = {}; //move[x_y] = x_new_y_new , a list of moves for this turn so we can process moves if move is succesful
var atom_intended_move = {}; //atoms_intended_move[xNew_yNew] = 1; for check to see if 2 atoms trying to occupy same space
var previous_board = []; //array for undo and failed moves to reset board. it will contain previous_board.push(JSON.stringify(board))
var touched = {}; //use this to ensure we do not loop through atoms again touched[x_y]=1;

//graphics area --------------------------  
  
var svg = {};  
  
svg['h'] = `<svg width="100%" height="100%"  viewBox="0 0 50 50">
<circle cx="25" cy="25" r="24" stroke="black" stroke-width="2" fill="white"></circle>
<text font-family='arial' font-color='black' x="50%" y="50%"  text-anchor="middle" stroke="black" stroke-width="1px" dy=".3em">He</text> 
</svg>`;
  
svg['H'] = `<svg width="100%" height="100%"  viewBox="0 0 50 50">
<circle cx="50%" cy="50%" r="47%" stroke="black" stroke-width="2" fill="IndianRed"></circle>
<text x="50%" y="50%" text-anchor="middle" stroke="#51c5cf" stroke-width="2px" dy=".3em">H</text>    
</svg>`;
  
svg['O'] = `<svg width="100%" height="100%"  viewBox="0 0 50 50">
<circle cx="25" cy="25" r="24" stroke="black" stroke-width="2" fill="CornflowerBlue"></circle>
<text x="25" y="25" text-anchor="middle" stroke="#51c5cf" stroke-width="2px" dy=".3em">O</text> 
</svg>`;

svg['N'] = `<svg width="100%" height="100%"  viewBox="0 0 50 50">
<circle cx="25" cy="25" r="24" stroke="black" stroke-width="2" fill="LightGreen"></circle>
<text x="25" y="25" text-anchor="middle" stroke="#51c5cf" stroke-width="2px" dy=".3em">N</text> 
</svg>`;
  
svg['C'] = `<svg width="100%" height="100%"  viewBox="0 0 50 50">
<circle cx="25" cy="25" r="24" stroke="black" stroke-width="2" fill="Khaki"></circle>
<text x="25" y="25" text-anchor="middle" stroke="#51c5cf" stroke-width="2px" dy=".3em">C</text> 
</svg>`;
  
svg['1bond_vert'] = `<svg width="100%" height="100%"  viewBox="0 0 5 50">
 <line x1="0" y1="25" x2="5" y2="25" style="stroke:black;stroke-width:2" />
</svg>`;  
  
svg['1bond_horiz'] = `<svg
   viewBox="0 0 13.229166 1.3229167"
   height="5"
   width="50">
  <g
     id="layer1"
     inkscape:groupmode="layer"
     inkscape:label="Layer 1">
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26571px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 6.7158266,0.01124925 v 1.32741645 0"
       id="path91-9" />
  </g>
</svg>`;
  
//msg vars -----------------------------

var how_to_play = `arrows: move 
r: reset
z: undo

Goal: Join all atoms with free valences
`;
  
var building_a_puzzle = `Building puzzles:
-the first line is an x_y value indicating the location of the atom you will control
-the following lines are the columns and rows of the puzzle
-the top left is x=0 , y=0 x being columns and y being rows
-characters can be W,0,1,2,3,4,h,H,O,N,C,+,-,.
-W = walls -they must be in locations where x and y are both even
-0 (zero) = empty -they can go anywhere
1,2,3,4 = bonds -they can go anywhere between two atoms, up to the capacity of the smallest valence. x and y must be even/odd or odd/even
h = helium -It has no free valence bonds and cannot join to other atoms. It must be in locations where x and y are both even
H = hydrogen -It has 1 free valence bonds. It must be in locations where x and y are both even  
O = oxygen -It has 2 free valence bonds. It must be in locations where x and y are both even  
N = nitrogen -It has 3 free valence bonds. It must be in locations where x and y are both even  
C = carbon -It has 4 free valence bonds. It must be in locations where x and y are both even  
+ = bond adder -bonds crossing this will increase by 1 if the atoms have free valences
- = bond subtractor -bonds crossing this will decrease by 1 
. = bond twister - bonds crossing this will wrap around it `;
   
//constructors ------------------------
  
function Atom(x , y , letter){ // Constructor
  this.is_a = 'atom';
  this.x = x;
  this.y = y;
  this.letter = letter; //H, h, O, N, C
  this.valence = {'h': 0 , 'H':1 , 'O':2 , 'N':3 , 'C':4}[letter]; //set on create based on letter
  //this.free_valence = this.valence;
  
  this.Can_I_Move = function(NEWS){ //also transfers force
    var dx = direction[NEWS].x;
    var dy = direction[NEWS].y;
    var x_y = this.x.toString() + '_' + this.y.toString(); 
    var all_news = Get_NEWS(this.x,this.y);
    var x_y_half_step = all_news[NEWS].x_y_half_step;
    var x_y_full_step =  all_news[NEWS].x_y_full_step;
    
    //1. check for a wall hit
    if(board[x_y_full_step].is_a === 'wall') {return false;} 
    touched[x_y]=1; //set this touched{x_y}=1 so we don't recurse into this atom again and create infite loops
    //2. check to see if something else is moving to the same location
    if(atom_intended_move[x_y_full_step]) {return false;} //and atom is already moving here. fail  
    //3. state atom's intention of moving here 
    atom_intended_move[x_y_full_step] = 1; //used to ensure 2 atoms are not fighting to move to same space
    
    //4. see if non bonded atom,not touched, is in our way, and see if it can move
    if(board[x_y_half_step].is_a !== 'bond'){//no bond in our way
      if(board[x_y_full_step].is_a === 'atom'){//atom in our way
        if(touched[x_y_full_step] !== 1){//hasn't been touched
          if(!board[x_y_full_step].Can_I_Move(NEWS)){return false;}
        }       
      }    
    }
    
    //see if bonds (not touched) can move 
    var all_news =  Get_NEWS(this.x,this.y) 
    for(var key in all_news){
      let x_y_half_step = all_news[key].x_y_half_step;
      let receiving_atom = all_news[key].x_y_full_step; //is where receiving atom is
      if(board[x_y_half_step].is_a === 'bond'){//a bond can only be crossed once, so no need to chech if touched
        if(!board[x_y_half_step].Can_I_Move(NEWS , receiving_atom)){return false;}
        //
      }
    }
        
    //if here, all downstream tests are good to move. but this does not mean that the move will not fail. 
    this.x = this.x + dx + dx;
    this.y = this.y + dy + dy;
    move[x_y] = x_y_full_step; //used to move atoms if we are good to go
    return true; 
    }; 

  this.Join_To_Free_Atoms = function(){
    //Return_Free_Valence of this atom
    var free_valence = this.Return_Free_Valence();
    //for adjacent atoms in direction with no bond && adjacent atoms with free valence , create a bond until my free_valence === 0
    //for(var key in direction){
    var all_news =  Get_NEWS(this.x,this.y) 
    for(var key in all_news){
      if(free_valence <= 0){return;}
      var x_half_step = all_news[key].x_half_step;
      var y_half_step = all_news[key].y_half_step;
      var x_y_half_step = all_news[key].x_y_half_step;
      var x_y_full_step = all_news[key].x_y_full_step;
      if(board[x_y_full_step].is_a === 'atom'){
        if(board[x_y_full_step].Return_Free_Valence() > 0){
          if(board[x_y_half_step].is_a === 'empty'){
          board[x_y_half_step] = new Bond(x_half_step,y_half_step,'1'); //add a bond
          free_valence--;
          }
        }
      }
    }    
  };
  
  this.Return_Free_Valence  = function(){
    //look in all directions and calculate  
    var sum = 0;
    var free_valence;
    var x_test;
    var y_test;
    var all_news =  Get_NEWS(this.x,this.y) 
    for(var key in all_news){
      var x_y = all_news[key].x_y_half_step;
      if(board[x_y].is_a === 'bond'){
        sum = sum + board[x_y].value;  
      }
    }
    free_valence = this.valence - sum; 
    if(free_valence < 0){
      console.log('Impossible free_valence at ' + x + '_' + y);
    }
    return free_valence;
  };
  
  return this; //return constructor
}
   
function Bond(x,y,letter){
  this.is_a = 'bond';
  this.x = x;
  this.y = y;
  this.letter = letter;
  //this.state = state; //this helps us choose correct bond graphics!
  this.value = parseInt(letter); 
  
  this.Can_I_Move = function(NEWS , receiving_atom){ //also transfers force
    var dx = direction[NEWS].x;
    var dy = direction[NEWS].y;
    var x_y = this.x.toString() + '_' + this.y.toString(); 
    var all_news = Get_NEWS(this.x,this.y);
    var x_y_half_step = all_news[NEWS].x_y_half_step;
    var x_y_full_step =  all_news[NEWS].x_y_full_step;
    touched[x_y]=1; //don't use this for bonds 
    //1.is there a bond_modifyer in the path - y ?
    if(board[x_y_half_step].is_a === 'bond_modifyer'){
      
    }
    //if receiving atom already touched just return true
    if(touched[receiving_atom]){ return true; }
    
    //transmit move / force to receiving atom
    if(!board[receiving_atom].Can_I_Move(NEWS)){return false;}
    
    //move bond
    this.x = this.x + dx + dx;
    this.y = this.y + dy + dy;
    move[x_y] = x_y_full_step; //used to move atoms if we are good to go
    return true;     
  }
   
  return this;
}
  
function Empty(x,y,letter){
  this.is_a = 'empty';
  this.letter = letter;
  this.x = x;
  this.y = y; 
  return this;
}
  
function Wall(x,y,letter){
  this.is_a = 'wall';
  this.x = x;
  this.y = y;
  this.letter = letter;  
  return this;
}
  
function Bond_Modifier(x,y,letter){
  this.is_a = 'bond_modifier';
  this.x = x;
  this.y = y;
  this.letter = letter;  
  return this;
  //- reduce bond by one
  //+ increase bond by one if joining atoms hav free valences
  // . if a bond hits it, the force transmitted by the bond will change to pull the receiving atom in the direction of the transmitting atom, the bond will move to 
}
  
//main routine--------------------------
  
function Key_Input(keyCode)
{ 
if(document.activeElement === document.getElementById('input_area')){
  return;
}
    
//esc : 27
  
if (keyCode == 82){ //r 82
  while(previous_board.length > 0){
    Set_Board( previous_board.pop() );
    Display_Objects(); 
  }
  return;
}
  
if (keyCode == 90){ //z:undo
  if( previous_board.length > 0){
    Set_Board( previous_board.pop() );
    Display_Objects(); 
    return; //do not hit move routine
    }
}
 
var move_key_pressed = false;
var NEWS;
if (keyCode == 37){ //left 
  NEWS = 'W';
  move_key_pressed = true;
}
  
if (keyCode == 38){ //up
  NEWS = 'N';
  move_key_pressed = true;
}
  
if (keyCode == 39){ //right
  NEWS = 'E';
  move_key_pressed = true;
}
  
if (keyCode == 40){ //down
  NEWS = 'S';
  move_key_pressed = true;
}
  
if(move_key_pressed){  
//clear and get ready for another move
move = {};
atom_intended_move = {};
touched = {};
 
if ( board[board.x_me+'_'+board.y_me].Can_I_Move(NEWS) ){  
  previous_board.push(JSON.stringify(board)); //save new board state
  //move[x_y] = 'x_y_new'
  //so for all premoves (keys) copy all the references temp[x_y]  = board[x_y] then board[x_y] = new empty(x,y) 
  //then for each x_y key copy to new position board[x_y_new] = temp[x_y]
  var temp = {};
  for(var key in move) { //save temp reference for all moving board objects. then remove the board references (set to empty)
    temp[key] = board[key];
    board[key] = new Empty(String_To_X_Y(key));
  }
  for(var key in move){ //now set all moved board references
    board[move[key]] = temp[key];
  }
  //move me
  x_y_me = move[board.x_me+'_'+board.y_me];
  [board.x_me,board.y_me] = String_To_X_Y(x_y_me);
  }
else{
    //nothing has moved, but reset board objects with last board state as some x,y may be wrong. recursive fail routine will miss some objects 
    Set_Board( previous_board[previous_board.length-1] );
    return; //skip next steps!
  }

}
  
Join_Free_Atoms(); //for every atom, check for atoms that can bond
Display_Objects();
}	

//board functions -----------------
  
function Build_Puzzle(input_string){ //build display board and board objects
board = {};
board.x_me=0;
board.y_me=0; 
board.width = 0;
board.height = 0; 
move = {};
atom_intended_move = {};
previous_board = [];
touched = {};
                    
input_string = input_string.trim();
var lines = input_string.split("\n"); //1st line is my position
x_y_me = lines.shift();
[board.x_me,board.y_me] = String_To_X_Y(x_y_me);
var y = -1;
var board_string = '<table>';
for(var line of lines){
  y++;
  board_string = board_string + '<tr>';
  if(y > board.height) { board.height = y; }
  var x = -1;  
  for(var letter of line){
    x++;    
    if(x > board.width) { board.width = x; }
    var state = State(x,y);
    var x_y = X_Y_To_String(x,y);    
    if(!validate_board_pos[state].includes(letter)){
       error_msg = error_msg + 'Letter ' + letter + ' not allowed in ' + state + ' position + ' + x_y + '. ';
       console.log(error_msg);
    }  
    board_string = board_string + '<td id=' + x_y + ' class=' + state + '></td>'; 
    
    //create the board[x_y] objects
    if(empty_chars.includes(letter)) { //0 indicates empty only 
      board[x_y] = new Empty(x,y);
    } 
    if( bond_chars.includes(letter) ) {
      board[x_y] = new Bond(x,y,letter);
    }
    if( wall_chars.includes(letter) ) {
      board[x_y] = new Wall(x,y,letter);
    }
    if( atom_chars.includes(letter) ) {
      board[x_y] = new Atom(x,y,letter);
    } 
    if( modifier_chars.includes(letter) ) { // + - .
      board[x_y] = new Bond_Modifier(x,y,letter);
    }
  }
  board_string = board_string + '</tr>';
}
board_string = board_string + '</table>';
document.getElementById("board").innerHTML = board_string;
if(error_msg !== ''){
 alert(error_msg); 
}
Join_Free_Atoms();
Display_Objects();
}
 
function Set_Board(json_string){
  var new_board = JSON.parse(json_string);
  board.x_me = new_board.x_me;
  board.y_me = new_board.y_me;
  board.width = new_board.width;
  board.height = new_board.height;
  for(var key in new_board){
    var x , y;
    [x,y] = String_To_X_Y(key);
    if(new_board[key].is_a === 'wall'){board[key] = new Wall(x,y,new_board[key].letter);}
    if(new_board[key].is_a === 'empty'){board[key] = new Empty(x,y,new_board[key].letter);}
    if(new_board[key].is_a === 'bond'){board[key] = new Bond(x,y,new_board[key].letter);}
    if(new_board[key].is_a === 'atom'){board[key] = new Atom(x,y,new_board[key].letter);}    
  }
}
  
function Display_Objects(){
  for(var y = 0 ; y <= board.height ; y++){
    for(var x = 0 ; x <= board.width ; x++){
      var x_y = X_Y_To_String(x,y);
      var element = document.getElementById(x_y);
      if(typeof board[x_y] === 'undefined'){
        continue;
      }
      if(board[x_y].is_a === 'empty'){
        element.innerHTML = '';
        element.classList.remove("me");
        //element.classList.remove("atom");
      }
      if(board[x_y].is_a === 'wall'){
       //element.innerHTML = board[x_y].letter;
       element.classList.add("wall");
      }
      if(board[x_y].is_a === 'atom'){
        element.innerHTML = svg[board[x_y].letter];
        if( (x === board.x_me) && (y === board.y_me) ){element.classList.add("me");}
        else{
          element.classList.remove("me");
        }
      }
      if(board[x_y].is_a === 'bond'){
        let state = document.getElementById(x_y).className; //are we bond_horiz or bon_vert
         //element.innerHTML = board[x_y].letter;
        element.innerHTML = svg[board[x_y].letter + state];
      }
      if(board[x_y].is_a === 'bond_modifier'){
        element.innerHTML = board[x_y].letter;
      }
          
    }
  }
}

//general functions -------------------------

function Join_Free_Atoms(){
  for(var key in board){
    if(board[key].is_a === 'atom'){
      board[key].Join_To_Free_Atoms();
    }
  }  
}
  
function X_Y_To_String(x,y){
  return x.toString()+'_'+y.toString();  
}
  
function String_To_X_Y( x_y ){//returns [x,y] int
  var x,y;
  [x,y] = x_y.split('_');  
  return [parseInt(x) , parseInt(y)];  
}
  
function Get_NEWS(x,y){
  var news = {};
  for(var key in direction){
      var dx = direction[key].x;
      var dy = direction[key].y;
      var x_half_step = x + dx;
      var y_half_step = y + dy;
      var x_full_step = x + dx + dx;
      var y_full_step = y + dy + dy;
      var x_y_half_step = x_half_step+'_'+y_half_step;
      var x_y_full_step = x_full_step+'_'+y_full_step;
      news[key] = {};
      news[key]['x_half_step'] = x_half_step;
      news[key]['y_half_step'] = y_half_step;    
      news[key]['x_full_step'] = x_full_step;
      news[key]['y_full_step'] = y_full_step;    
      news[key]['x_y_half_step'] = x_y_half_step;
      news[key]['x_y_full_step'] = x_y_full_step;
  }
return news; 
}
  
function State(x,y){
  var x_odd = x%2;
  var y_odd = y%2;
  if ( x_odd && y_odd ){return 'hyperspace';}
  if ( !x_odd && !y_odd ){return 'vacuum';}
  if ( x_odd && !y_odd ){return 'bond_vert';}
  if ( !x_odd && y_odd ){return 'bond_horiz';}
}
  
//free roaming code ----------------------------
  
Build_Puzzle(document.getElementById("input_area").value);
  
//disable arrow keys from scrolling page
window.addEventListener("keydown", function(e) {
    // space and arrow keys
    if([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
        e.preventDefault();
    }
}, false);
  
//to do ---------------------------------------
//win state
//bond_modifiers
//me atom
//mouse click and move
//scalable board
//loadable game boards
//puzzle editor
//puzzle save routine
  
  
//all atom forces must be transmitted in order from source to receiver 
</script>
</body>
</html>
