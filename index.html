<!DOCTYPE html>

<meta name="robots" content="noindex">
<html>
<head>
<meta name="description" content="Sokobond JS">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Sokobond JS</title>
</head>
<body>
<h4>Sokobond JS</h4>  
  
<style>
.table 
  {
  display: table;  
  border : solid;
  border-width: 1px;
  }
.tr 
  { 
  display: table-row; 
  }
.td 
  { 
  display: table-cell;
  border : solid;
  border-width: 1px;
  text-align: center;
  vertical-align: middle;
  }    
.atom
  {
  width: 50px;
  height: 50px;
  }
  
.bond
  {
  width: 15px;  
  height: 15px; 
  border : none;
  }

</style>

<div class="table">
    <div class="tr">
        <div class="td atom">C</div>
        <div class="td bond">▬
      ▬      
▬</div>
        <div class="td atom">a</div>
         <div class="td bond">a</div>
        <div class="td atom">He</div>
    </div>
    <div class="tr">
        <div class="td bond">│││</div>
        <div class="td bond">+</div>
        <div class="td bond">a</div>
        <div class="td bond">-</div>
        <div class="td bond">a</div>
    </div>    
    <div class="tr">
        <div class="td atom">O</div>
        <div class="td bond">a</div>
        <div class="td atom">a</div>
         <div class="td bond">a</div>
        <div class="td atom">a</div>
    </div>
    <div class="tr">
        <div class="td bond">a</div>
        <div class="td bond">•</div>
        <div class="td bond">a</div>
        <div class="td bond">a</div>
        <div class="td bond">a</div>
    </div>    
    <div class="tr">
        <div class="td atom">a</div>
        <div class="td bond">a</div>
        <div class="td atom">a</div>
         <div class="td bond">a</div>
        <div class="td atom">a</div>
    </div>
</div>

<script>  
var msg; //for errors
  
var input_string = `4_2
W0W0W0W0W0W0W0W0W
00000000000000000
W000C00000000000W
00000000000000000
W000000000000000W
00000000000000000
W00000H000H00000W
00000000000000000
W000000000000000W
00000000000000000
W0W0W0W0W0W0W0W0W
`;  

//0 indicates vacuum only 
var atom_chars = ['H','h','O','C','N'];
var even_char = atom_chars.concat( ['0','W'] ); //E=empty, W=wall, H=hydrogen, h=helium, O=oxygen, C=carbon, N=nitrogen 
var odd_chars = ['0','+','-','.']; //+ = bond_joiner , - = bond_splitter , . = bond_twister
var mixed_chars = ['0','1','2','3','4']; 

var dir = {
 'N' : { 'x':0 , 'y':-1  },
 'S' : { 'x':0 , 'y':1  },
 'E' : { 'x':1 , 'y':0  },
 'W' : { 'x':-1 , 'y':0  }  
}
var me = {}; //atom but a special one  
var board = {}; //board just used to shows icons aand set bounds?
board.width;
board.height;  
var walls = {};
var atoms = {}; // atom['x_y'] = new atom(x,y,letter);
var bonds = {}; //bond['x_y'] = new bond(x,y,number)
var bond_spliters = {}; //spliters[x_y] = 1; //decrease bond # by 1 and split molecules in two if 0
  //spliters.Return_Spliters() 
var bond_joiners = {}; //increase bond # by 1 if both atoms have free valance 
var bond_twisters = {}; //if a bond hits it, the force transmitted by the bond will change to pull the receiving atom in the direction of the transmitting atom, the bond will move to 
var intended_atom_moves = {}; //intended_atom_moves[xNew_yNew] = atom[x_y];
var intended_bond_moves = {}; 
  //references to atoms and bonds, but with new x_y. an external move routine will cycle through intended move object keys. if there is nothing there at x_y, move it, and zero that key, then cycle again until no keys
//WILL NOT WORK IN A RING? ?
//so: Wipe all atoms = {}; and rebuild with intended_atom_moves then intended_atom_moves = {};
//also used to see if two atoms are vying for same spot durin move test!
  
function Atom(x , y , letter){ // Constructor
  this.isA = 'atom';
  this.x = x;
  this.y = y;
  this.direction;
  this.letter = letter; //H, h, O, N, C
  this.valence = {'h': 0 , 'H':1 , 'O':2 , 'N':3 , 'C':4}[letter]; //set on create based on letter
   
   this.Can_I_Move = function(direction){ //also transfers force
    this.direction = direction;
    //are we outside bounds, fail immediately
    //is there a wall in my way? Y - return fail immediately
    //set this touched{x_y}=1 so we don't recurse into this atom again and create infite loops
    //copy atom object to new position in var intended_moves{x_y} = this (if it is already set, fail immediately as two atoms cannot occupy same space) (this will also be used to move atoms if we are good to go) 
    //recursivly, to all bonds and atoms in "transfer force direction" (that are not already touched{x_y}=1) and await response that they can move. if one fails, immediately return fail 
    //move()
    return true; 
    } 

  this.Join_To_Free_Atoms = function(){
  //recurstive routine like move OR maybe global x_y loop is better and easier!!!
  }
  
  this.Return_Free_Valance  = function(){
  //look in all directions and calculate  
  }
  
  return this; //return constructor
};
   
function Bond(x,y,value){
  this.isA = 'bond';
  this.x = x;
  this.y = y;
  this.value = value;
  
  return this;
}
  
function Wall(){
  this.isA = 'wall';
  return this;  
}
  
function Splitter(x,y){
  this.isA = 'spliter';
  this.x = x;
  this.y = y;
  
  return this;  
}
  
function Joiner(x,y){
  this.isA = 'joiner';
  this.x = x;
  this.y = y;
  
  return this;  
}
  
function Twister(x,y){
  this.isA = 'twister';
  this.x = x;
  this.y = y;
  
  return this;  
}
  
function State(x,y){
var x_odd = x%2;
var y_odd = y%2;
if ( x_odd && y_odd ){return 'odd'}
if ( !x_odd && !y_odd ){return 'even'}
return 'mixed';
}
  
input_string = input_string.trim();
var lines = input_string.split("\n");
//1st line is my position
var x_me ,y_me;
[x_me,y_me] = lines.shift().split('_');
var y = -1;
for(var line of lines){
  y++;
  var x = -1;
  for(var letter of line){
    //test for odds, evens, mixed
    x++;
    var state = State(x,y);
    var x_y = x.toString() + '_' + y.toString();
    if(letter === '0') {continue} //0 indicates vacuum only  
    //bonds
    if( mixed_chars.includes(letter) ) {
      if( state !== 'mixed' ){
        msg = letter + ' in wrong spot ' + x + ',' + y;
        throw msg;
      }
      bonds[x_y] = new Bond(x,y,parseInt(letter));
    }
    //walls
    if( letter === 'W' ) {
      if( state !== 'even' ){
        msg = letter + ' in wrong spot ' + x + ',' + y;
        throw msg;
      }
      walls[x_y] = new Wall();
    }
    //atoms
    if( atom_chars.includes(letter) ) {
      if( state !== 'even' ){
        msg = letter + ' in wrong spot ' + x + ',' + y;
        throw msg;
      }
      if( (x == x_me) && (y == y_me) ){
       atoms[x_y] = new Atom(x,y,letter); 
       me = atoms[x_y];
      }
      else{
        atoms[x_y] = new Atom(x,y,letter);
      }
    }
        
    if( letter === '-' ){
      if( state !== 'odd' ){
        msg = letter + ' in wrong spot ' + x + ',' + y;
        throw msg;
      }      
      bond_spliters[x_y] = new Splitter(x,y);                                       
    }
    
    if( letter === '+' ){
      if( state !== 'odd' ){
        msg = letter + ' in wrong spot ' + x + ',' + y;
        throw msg;
      }      
      bond_joiners[x_y] = new Joiner(x,y);                                     
    }
    
    if( letter === '.' ){
      if( state !== 'odd' ){
        msg = letter + ' in wrong spot ' + x + ',' + y;
        throw msg;
      }      
      bond_twister[x_y] = new Twister(x,y);                                     
    } 
    
  }
}

//me.isA = 'Me';
console.log( me );
console.log( me.isA );

//What would a win look like and how do we test for it?

//all atom forces must be transmited in order from source to reciever as nature does this
  
//main loop
  //check for bonding
  //try to move my atom, recursivly check each joined or ajoining atom
 //y - move
  //are all atoms in the same molecule? win
  
</script>rsu
</body>
</html>
