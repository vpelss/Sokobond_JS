<!DOCTYPE html>

<meta name="robots" content="noindex">
<html>
<head>
<meta name="description" content="Sokobond JS">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Sokobond JS</title>
</head>

<body  ONKEYUP="Key_Input(event.keyCode);">
  
<h4>Sokobond JS</h4>  

<style>  
div{ 
  -float: left;
  -border : solid; 
  -border-width: 1px;  
  }
  
.me{
background-color: coral;   
}
.vacuum{    
  display: inline-block;
   text-align: center;

  width: 50px;
  height: 50px;
   
  border : solid; 
  border-width: 1px;  
  }
  
.bond_vert{
  display: inline-block;
   text-align: center;
  
  width: 15px; 
  height: 50px;
  }

.bond_horiz{
  display: inline-block;
   text-align: center;
  
  padding: 1px;
  width: 50px;
  height: 15px;     
  }
  
.hyperspace{
  display: inline-block;
   text-align: center;
  
  width: 15px;  
  height: 15px;   
  }
    
</style>
arrows: move
<br>
r: reset
<br>
z: undo
<p>
<div id=board></div>

<script>  
var msg; //for errors
  
var input_string = `4_2
W0W0W0W0W0W0W0W0W
00000000000000000
W000C00000000000W
0000000000000.000
W000000000000000W0W0W0W
00000000000-00000
W00000H000H00000W
00000+00000000000
W0000000H0H00000W0W
00000000000000000
W0W0W0W0W0W0W0W0W0W0W
`;  

var empty_chars = ['0']; 
var atom_chars = ['H','h','O','C','N'];
var even_chars = atom_chars.concat( ['0','W'] ); //E=empty, W=wall, H=hydrogen, h=helium, O=oxygen, C=carbon, N=nitrogen 
var modifier_chars = ['+','-','.'];
var bond_chars = ['1','2','3','4']; 
var direction = {
 'N' : { 'x':0 , 'y':-1  },
 'S' : { 'x':0 , 'y':1  },
 'E' : { 'x':1 , 'y':0  },
 'W' : { 'x':-1 , 'y':0  }  
}

var x_y_me='';
var board = {}; //x,y,can_be=[empty,wall,atom,bond,bond_modifier], is_a , obj (atom,bond,wall..) , class
//allows us to save board (stringify) then easily restore by parse and object.assign for each spot on board.  
board.x_me=0 
board.y_me=0; 
board.width = 0;
board.height = 0;  
var move = {}; //intended_move[x_y] = x_new_y_new
var atom_intended_move = {}; //atoms_intended_move[xNew_yNew] = 1; for check to see if 2 atoms trying to occupy same space
//var the_last_board = {}; //
var previous_board = []; //array for undo and failed moves to reset board. it will contain previous_board.push(JSON.stringify(board))
var touched = {}; //use this to ensure we do not loop through atoms again touched[x_y]=1;
  
function Atom(x , y , letter){ // Constructor
  this.is_a = 'atom';
  this.x = x;
  this.y = y;
  this.letter = letter; //H, h, O, N, C
  this.valence = {'h': 0 , 'H':1 , 'O':2 , 'N':3 , 'C':4}[letter]; //set on create based on letter
  this.free_valence = this.valence;
  
  this.Can_I_Move = function(x,y,dx,dy){ //also transfers force
    this.x = x;
    this.y = y; //reset as x,y might be wrong due to a previously failed move
    var x_y = x.toString() + '_' + y.toString(); 
    var x_half_step = x + dx;
    var y_half_step = y + dy;
    var x_full_step = x + dx + dx;
    var y_full_step = y + dy + dy;
    var x_y_half_step = x_half_step+'_'+y_half_step;
    var x_y_full_step = x_full_step+'_'+y_full_step;
    
    if(board[x_y_full_step].is_a === 'wall') {return false} //hit a wall
    touched[x_y]=1; //set this touched{x_y}=1 so we don't recurse into this atom again and create infite loops
    if(atom_intended_move[x_y_full_step]) {return false} //and atom is already moving here. fail  
    atom_intended_move[x_y_full_step] = 1; //used to move atoms if we are good to go
    
    //see if non bonded atom (not touched), in our way, can move
    if(board[x_y_half_step].is_a !== 'bond'){//no bond in our way
      if(board[x_y_full_step].is_a === 'atom'){//atom in our way
        if(touched[x_y_full_step] !== 1){//hasn't been touched
          if(!board[x_y_full_step].Can_I_Move(x_full_step,y_full_step,dx,dy)){return false}
        }       
      }    
    }
    
    //see if bonds (not touched) can move 

    //if here, all downstream tests are good to move. but this does not mean hat the move will not fail. 
    this.x = x_full_step;
    this.y = y_full_step;
    move[x_y] =x_y_full_step; 
    return true; 
    } 

  this.Join_To_Free_Atoms = function(){
  //recurstive routine like move OR maybe global x_y loop is better and easier!!!
  }
  
  this.Return_Free_Valance  = function(){
  //look in all directions and calculate  
  }
  
  return this; //return constructor
};
   
function Bond(x,y,letter){
  this.is_a = 'bond';
  this.x = x;
  this.y = y;
  this.letter = letter;
  this.value = parseInt(letter); 
  return this;
}
  
function Empty(x,y,letter){
  this.is_a = 'empty';
  this.x = x;
  this.y = y; 
  return this;
}
  
function Wall(x,y,letter){
  this.is_a = 'wall';
  this.x = x;
  this.y = y;
  this.letter = letter;  
  return this;
}
  
function Bond_Modifier(x,y,letter){
  this.is_a = 'bond_modifier';
  this.x = x;
  this.y = y;
  this.letter = letter;  
  return this;
  //- reduce bond by one
  //+ increase bond by one if joining atoms hav free valances
  // . if a bond hits it, the force transmitted by the bond will change to pull the receiving atom in the direction of the transmitting atom, the bond will move to 
}
  
function State(x,y){
var x_odd = x%2;
var y_odd = y%2;
if ( x_odd && y_odd ){return 'hyperspace'}
if ( !x_odd && !y_odd ){return 'vacuum'}
if ( x_odd && !y_odd ){return 'bond_vert'}
if ( !x_odd && y_odd ){return 'bond_horiz'}
}
  
//document.getElementById("board").innerHTML = "<h1>dfsdfdsadf</h1>";
function Next_Div(x_y , state){
board_string = board_string + '<div id=' + x_y + ' class=' + state + '>&nbsp;</div>';  
}

function X_Y_To_String(x,y){
return x_y = x.toString() + '_' + y.toString();  
}
  
function String_To_X_Y( x_y ){//returns [x,y] int
var x,y;
[x,y] = x_y.split('_');  
return [parseInt(x) , parseInt(y)];  
}
  
//build display board and board objects
input_string = input_string.trim();
var lines = input_string.split("\n");
//1st line is my position
x_y_me = lines.shift();
[board.x_me,board.y_me] = String_To_X_Y(x_y_me);
var y = -1;
var board_string = '';
for(var line of lines){
  y++;
  if(y > board.height) { board.height = y }
  var x = -1;
  for(var letter of line){
    x++;
    if(x > board.width) { board.width = x }
    var state = State(x,y);
    var x_y = X_Y_To_String(x,y);
    
    Next_Div(x_y , state);
    
    if(empty_chars.includes(letter)) { //0 indicates empty only 
      board[x_y] = new Empty(x,y);
    } 
    //bonds
    if( bond_chars.includes(letter) ) {
      board[x_y] = new Bond(x,y,letter);
    }
    //walls
    if( letter === 'W' ) {
      board[x_y] = new Wall(x,y,letter);
    }
    //atoms
    if( atom_chars.includes(letter) ) {
      board[x_y] = new Atom(x,y,letter);
    }
        
    if( modifier_chars.includes(letter) ) { // + - .
      board[x_y] = new Bond_Modifier(x,y,letter);
    }
  }
board_string = board_string + '<br>';
}
  
document.getElementById("board").innerHTML = board_string;
//the_last_board = JSON.stringify(board); //save first board
  
//now display objects
function Display_Objects(){
  for(var y = 0 ; y <= board.height ; y++){
    for(var x = 0 ; x <= board.width ; x++){
      var x_y = X_Y_To_String(x,y);
      var element = document.getElementById(x_y);
      if(typeof board[x_y] === 'undefined'){
        continue;
      };
      if(board[x_y].is_a === 'empty'){
        element.innerHTML = '&nbsp;';
        element.classList.remove("me");
      };
      if(board[x_y].is_a === 'wall'){
       element.innerHTML = board[x_y].letter;
      };
      if(board[x_y].is_a === 'atom'){
        element.innerHTML = board[x_y].letter;
        if( (x === board.x_me) && (y === board.y_me) ){element.classList.add("me")}
        else{
          element.classList.remove("me")
        }
      }
      if(board[x_y].is_a === 'bond'){
        element.innerHTML = board[x_y].letter;
      };
      if(board[x_y].is_a === 'bond_modifier'){
        element.innerHTML = board[x_y].letter;
      };
          
    }
  }
}

Display_Objects();
  
function Key_Input(keyCode)
{
if (keyCode == 82){ //r 82

}
  
if (keyCode == 90){ //z:undo
  if( previous_board.length > 0){
    Set_Board( previous_board.pop() );
    Display_Objects(); 
    return; //do not hit move routine
    }
}
  
var NEWS;
if (keyCode == 37){ //left 
  NEWS = 'W';
}
  
if (keyCode == 38){ //up
  NEWS = 'N';
}
  
if (keyCode == 39){ //right
  NEWS = 'E';
}
  
if (keyCode == 40){ //down
  NEWS = 'S';
}
  
//clear and get ready for another move
move = {};
atom_intended_move = {};
touched = {};
if ( board[board.x_me+'_'+board.y_me].Can_I_Move(board.x_me,board.y_me,direction[NEWS].x , direction[NEWS].y) ){  
  //move[x_y] = 'x_y_new'
  //so for all premoves (keys) copy all the references temp[x_y]  = board[x_y] then board[x_y] = new empty(x,y) 
  //then for each x_y key copy to new position board[x_y_new] = temp[x_y]
  previous_board.push(JSON.stringify(board)); //save new board state
  //the_last_board = JSON.stringify(board);//store this move for undo before we move
  var temp = {};
  for(var key in move) { //save temp reference for all moving board objects. then remove the board references (set to empty)
    temp[key] = board[key];
    board[key] = new Empty(String_To_X_Y(key));
  }
  for(var key in move){ //now set all moved board references
    board[move[key]] = temp[key];
  }
  //move me
  x_y_me = move[board.x_me+'_'+board.y_me];
  [board.x_me,board.y_me] = String_To_X_Y(x_y_me);
  Display_Objects();
  }
else{
    //nothing has moved, but reset board objects with last board state as some x,y may be wrong. recursive fail routine will miss some objects 
    Set_Board( previous_board[previous_board.length-1] );
  }

//esc : 27
}	
  
function Set_Board(json_string){
  var new_board = JSON.parse(json_string);
  board.x_me = new_board.x_me;
  board.y_me = new_board.y_me;
  board.width = new_board.width;
  board.height = new_board.height;
  for(var key in new_board){
    var x , y;
    [x,y] = String_To_X_Y(key);
    if(new_board[key].is_a === 'wall'){board[key] = new Wall(x,y,new_board[key].letter)}
    if(new_board[key].is_a === 'empty'){board[key] = new Empty(x,y,new_board[key].letter)}
    if(new_board[key].is_a === 'bond'){board[key] = new Bond(x,y,new_board[key].letter)}
    if(new_board[key].is_a === 'atom'){board[key] = new Atom(x,y,new_board[key].letter)}    
  }
}

//What would a win look like and how do we test for it?

//all atom forces must be transmited in order from source to reciever 

  </script>
</body>
</html>
