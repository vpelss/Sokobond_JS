<!DOCTYPE html>

<meta name="robots" content="noindex">
<html>
<head>
<meta name="description" content="Sokobond JS">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Sokobond JS</title>
</head>

<body  ONKEYUP="Key_Input(event.keyCode);">
  
<h4>Sokobond JS</h4>  

<style>  
div{ 
  -float: left;
  -border : solid; 
  -border-width: 1px;  
  }

.vacuum{    
  display: inline-block;
   text-align: center;

  width: 50px;
  height: 50px;
   
  border : solid; 
  border-width: 1px;  
  }
  
.bond_vert{
  display: inline-block;
   text-align: center;
  
  width: 15px; 
  height: 50px;
  }

.bond_horiz{
  display: inline-block;
   text-align: center;
  
  padding: 1px;
  width: 50px;
  height: 15px;     
  }
  
.hyperspace{
  display: inline-block;
   text-align: center;
  
  width: 15px;  
  height: 15px;   
  }
    
</style>
  
<div id=board></div>

<script>  
var msg; //for errors
  
var input_string = `4_2
W0W0W0W0W0W0W0W0W
00000000000000000
W000C00000000000W
0000000000000.000
W000000000000000W0W0W0W
00000000000-00000
W00000H000H00000W
00000+00000000000
W0000000H1H00000W0W
00000000000000000
W0W0W0W0W0W0W0W0W0W0W
`;  

var empty_chars = ['0']; 
var atom_chars = ['H','h','O','C','N'];
var even_chars = atom_chars.concat( ['0','W'] ); //E=empty, W=wall, H=hydrogen, h=helium, O=oxygen, C=carbon, N=nitrogen 
var modifier_chars = ['+','-','.'];
var bond_chars = ['1','2','3','4']; 
var direction = {
 'N' : { 'x':0 , 'y':-2  },
 'S' : { 'x':0 , 'y':2  },
 'E' : { 'x':2 , 'y':0  },
 'W' : { 'x':-2 , 'y':0  }  
}
var x_y_me='';
var x_me=0 , y_me=0; 
var me = {}; //atom but a special one  
var board = {}; //x,y,can_be=[empty,wall,atom,bond,bond_modifier], is_a , obj (atom,bond,wall..) , class
//allows us to save board (stringify) then easily restore by parse and object.assign for each spot on board.  
board.width = 0;
board.height = 0;  
var move = {}; //intended_move[x_y] = x_new_y_new
var atom_intended_move = {}; //atoms_intended_move[xNew_yNew] = 1; for check to see if 2 atoms trying to occupy same space
var previous_board = []; //array for undo and failed moves to reset board. it will contain previous_board.push(JSON.stringify(board))
var touched = {}; //use this to ensure we do not loop through atoms again touched[x_y]=1;
  
function Atom(x , y , letter){ // Constructor
  this.is_a = 'atom';
  this.x = x;
  this.y = y;
  this.letter = letter; //H, h, O, N, C
  this.valence = {'h': 0 , 'H':1 , 'O':2 , 'N':3 , 'C':4}[letter]; //set on create based on letter
   
  this.Can_I_Move = function(x,y,dx,dy){ //also transfers force
    this.x = x;
    this.y = y; //reset as x,y might be wrong due to a previously failed move
    var x_y = x.toString() + '_' + y.toString(); 
    var x_new = x + dx;
    var y_new = y + dy;
    var x_y_new = x_new.toString() + '_' + y_new.toString();
    //if(walls[x_y_new]) {return false} //hit a wall
    if(board[x_y_new].is_a === 'wall') {return false} //hit a wall
    //are we outside bounds, fail immediately
    touched[x_y]=1; //set this touched{x_y}=1 so we don't recurse into this atom again and create infite loops
    if(atom_intended_move[x_y_new]) {return false} //and atom is already moving here. fail  
    atom_intended_move[x_y_new] = 1; //used to move atoms if we are good to go
     
    //recursivly, to all bonds and atoms in "transfer force direction" (that are not already touched{x_y}=1) and await response that they can move. if one fails, immediately return fail 
    //move()

    //atoms_pre_move[x_y] = this; 
    this.x = x_new;
    this.y = y_new;
    //atoms_intended_move[x_y_new] = this; //copy ref to this atom and
    move[x_y] = x_y_new; 
    return true; 
    } 

  this.Join_To_Free_Atoms = function(){
  //recurstive routine like move OR maybe global x_y loop is better and easier!!!
  }
  
  this.Return_Free_Valance  = function(){
  //look in all directions and calculate  
  }
  
  return this; //return constructor
};
   
function Bond(x,y,letter){
  this.is_a = 'bond';
  this.x = x;
  this.y = y;
  this.letter = letter;
  this.value = parseInt(letter); 
  return this;
}
  
function Empty(x,y){
  this.is_a = 'empty';
  this.x = x;
  this.y = y; 
  return this;
}
  
function Wall(x,y,letter){
  this.is_a = 'wall';
  this.x = x;
  this.y = y;
  this.letter = letter;  
  return this;
}
  
function Bond_Modifier(x,y,letter){
  this.is_a = 'bond_modifier';
  this.x = x;
  this.y = y;
  this.letter = letter;  
  return this;
  // . if a bond hits it, the force transmitted by the bond will change to pull the receiving atom in the direction of the transmitting atom, the bond will move to 
}
  
function State(x,y){
var x_odd = x%2;
var y_odd = y%2;
if ( x_odd && y_odd ){return 'hyperspace'}
if ( !x_odd && !y_odd ){return 'vacuum'}
if ( x_odd && !y_odd ){return 'bond_vert'}
if ( !x_odd && y_odd ){return 'bond_horiz'}
}
  
//document.getElementById("board").innerHTML = "<h1>dfsdfdsadf</h1>";
function Next_Div(x_y , state){
board_string = board_string + '<div id=' + x_y + ' class=' + state + '>&nbsp;</div>';  
}

function X_Y_To_String(x,y){
return x_y = x.toString() + '_' + y.toString();  
}
  
function String_To_X_Y( x_y ){//returns [x,y] int
var x,y;
[x,y] = x_y.split('_');  
return [parseInt(x) , parseInt(y)];  
}
  
//build display board and board objects
input_string = input_string.trim();
var lines = input_string.split("\n");
//1st line is my position
x_y_me = lines.shift();
[x_me,y_me] = String_To_X_Y(x_y_me);
var y = -1;
var board_string = '';
for(var line of lines){
  y++;
  if(y > board.height) { board.height = y }
  var x = -1;
  for(var letter of line){
    x++;
    if(x > board.width) { board.width = x }
    var state = State(x,y);
    var x_y = X_Y_To_String(x,y);
    
    Next_Div(x_y , state);
    
    if(empty_chars.includes(letter)) { //0 indicates empty only 
      board[x_y] = new Empty(x,y);
    } 
    //bonds
    if( bond_chars.includes(letter) ) {
      board[x_y] = new Bond(x,y,letter);
    }
    //walls
    if( letter === 'W' ) {
      board[x_y] = new Wall(x,y,letter);
    }
    //atoms
    if( atom_chars.includes(letter) ) {
      board[x_y] = new Atom(x,y,letter);
    }
        
    if( modifier_chars.includes(letter) ) { // + - .
      board[x_y] = new Bond_Modifier(x,y,letter);
    }
  }
board_string = board_string + '<br>';
}
  
document.getElementById("board").innerHTML = board_string;
previous_board.push(JSON.stringify(board)); //save first board
  
//now display objects
function Display_Objects(){
  for(var y = 0 ; y <= board.height ; y++){
    for(var x = 0 ; x <= board.width ; x++){
      var x_y = X_Y_To_String(x,y);
      if(typeof board[x_y] === 'undefined'){
        continue;
      };
      if(board[x_y].is_a === 'empty'){
        document.getElementById(x_y).innerHTML = '&nbsp;';
      };
      if(board[x_y].is_a === 'wall'){
        document.getElementById(x_y).innerHTML = board[x_y].letter;
      };
      if(board[x_y].is_a === 'atom'){
        document.getElementById(x_y).innerHTML = board[x_y].letter;
      };
      if(board[x_y].is_a === 'bond'){
        document.getElementById(x_y).innerHTML = board[x_y].letter;
      };
      if(board[x_y].is_a === 'bond_modifier'){
        document.getElementById(x_y).innerHTML = board[x_y].letter;
      };
           
    }
  }
}

Display_Objects();
 
//test area
var temp = JSON.stringify(board);
var temp2 = JSON.parse(temp);
//board = {};
//Object.assign(board,temp2); 

function Reload_Board( json_string ){
  board = {};
  Object.assign(board,temp2);
  //must build atoms and bonds with methods
  
}
 
//Display_Objects();

//console.log( JSON.stringify(board) );
//console.log( board );
 
//What would a win look like and how do we test for it?

//all atom forces must be transmited in order from source to reciever as nature does this
  
//undo_atom_array / undo_bond_array : each succesful move, create an array of all the moves : on Z, set pop delete current move
 //probabl need to make arrays of an array showing to / from [x_y->x_y]  

//main loop
  //check for bonding
  //try to move my atom, recursivly check each joined or ajoining atom
 //y - move
  //are all atoms in the same molecule? win
  
function Key_Input(keyCode)
{
var NEWS;
if (keyCode == 37){ //left 
  NEWS = 'W';
}
  
if (keyCode == 38){ //up
  NEWS = 'N';
}
  
if (keyCode == 39){ //right
  NEWS = 'E';
}
  
if (keyCode == 40){ //down
  NEWS = 'S';
}
  
if ( board[x_me+'_'+y_me].Can_I_Move(x_me,y_me,direction[NEWS].x , direction[NEWS].y) ){  
  //move[x_y] = 'x_y_new'
  //so for all premoves (keys) copy all the references temp[x_y]  = board[x_y] then board[x_y] = new empty(x,y) 
  //then for each x_y key copy to new position board[x_y_new] = temp[x_y]
  var temp = {};
  for(var key in move) { //save temp reference to all moving board objects. then remove the board references (set to empty)
    temp[key] = board[key];
    board[key] = new Empty(String_To_X_Y(key));
  }
  for(var key in move){ 
    board[move[key]] = temp[key];
  }
  previous_board.push(JSON.stringify(board)); //save new board state
  Display_Objects();
  x_y_me = move[key];
  [x_me,y_me] = String_To_X_Y(x_y_me);
  }
else{
    //nothing has moved, but reset board objects with last board state as some x,y may be wrong. recursive fail routine will miss some objects 
    board = {};
    board = previous_board[previous_board.length-1];
    move = {};
    atom_intended_move = {};
    touched = {};
  }

//esc : 27
//r 82
//z 90

}	

</script>
</body>
</html>
