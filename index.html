<!DOCTYPE html>

<meta name="robots" content="noindex">
<html>
<head>
<meta name="description" content="Sokobond JS Chemical Zen">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Sokobond JS</title>
</head>

<body  ONKEYUP="Key_Input(event.keyCode);">
  
<h4><meta name="description" content="Sokobond JS Chemical Zen">
</h4>  

<style>  
div{ 
  -float: left;
  -border : solid; 
  -border-width: 1px;  
  }
  
.me{
background-color: coral;   
}
.vacuum{    
  display: inline-block;
   text-align: center;

  width: 50px;
  height: 50px;
   
  border : solid; 
  border-width: 1px;  
  }
  
.bond_vert{
  display: inline-block;
   text-align: center;
  
  width: 15px; 
  height: 50px;
  }

.bond_horiz{
  display: inline-block;
   text-align: center;
  
  padding: 1px;
  width: 50px;
  height: 15px;     
  }
  
.hyperspace{
  display: inline-block;
   text-align: center;
  
  width: 15px;  
  height: 15px;   
  }
    
</style>
arrows: move
<br>
r: reset
<br>
z: undo
<p>
<div id=board></div>
<p>
<textarea id="input_area" rows="4" cols="50">
4_2
W0W0W0W0W0W0W0W0W
00000000000000000
W000C000H0000000W
0000000000000.000
W00000H000000000W0W0W0W
00000000000-00000
W00000H000H00000W
00000+00000000000
W0000000H0H00000W0W
00000000000000000
W0W0W0W0W0W0W0W0W0W0W
</textarea>
  
  <form action="#">
  <input type="button" value="Refresh Puzzle" onclick='Build_Puzzle(document.getElementById("input_area").value);'>
</form>
  
<script>  
var error_msg = '';
var input_string;
var empty_chars = ['0']; 
var atom_chars = ['H','h','O','C','N'];
var wall_chars = ['W'];
var modifier_chars = ['+','-','.'];
var bond_chars = ['1','2','3','4'];
var validate_board_pos = {};  //note keys match state/class so we can do build board error checking
validate_board_pos['hyperspace'] = empty_chars.concat(modifier_chars);
validate_board_pos['vacuum'] = empty_chars.concat(atom_chars,wall_chars);
validate_board_pos['bond_vert'] = empty_chars.concat(bond_chars);
validate_board_pos['bond_horiz'] = empty_chars.concat(bond_chars);    
var direction = {
 'N' : { 'x':0 , 'y':-1  },
 'S' : { 'x':0 , 'y':1  },
 'E' : { 'x':1 , 'y':0  },
 'W' : { 'x':-1 , 'y':0  }  
};
 
function Get_NEWS(x,y){
  var news = {};
  for(var key in direction){
      var dx = direction[key].x;
      var dy = direction[key].y;
      var x_half_step = x + dx;
      var y_half_step = y + dy;
      var x_full_step = x + dx + dx;
      var y_full_step = y + dy + dy;
      var x_y_half_step = x_half_step+'_'+y_half_step;
      var x_y_full_step = x_full_step+'_'+y_full_step;
      news[key] = {};
      news[key]['x_half_step'] = x_half_step;
      news[key]['y_half_step'] = y_half_step;    
      news[key]['x_full_step'] = x_full_step;
      news[key]['y_full_step'] = y_full_step;    
      news[key]['x_y_half_step'] = x_y_half_step;
      news[key]['x_y_full_step'] = x_y_full_step;
  }
return news; 
}

var x_y_me='';
var board = {}; //x,y,can_be=[empty,wall,atom,bond,bond_modifier], is_a , obj (atom,bond,wall..) , class
//allows us to save JSON.stringify(board) then easily rebuild each object on board.  
var move = {}; //move[x_y] = x_new_y_new , a list of moves for this turn so we can process moves if move is succesful
var atom_intended_move = {}; //atoms_intended_move[xNew_yNew] = 1; for check to see if 2 atoms trying to occupy same space
var previous_board = []; //array for undo and failed moves to reset board. it will contain previous_board.push(JSON.stringify(board))
var touched = {}; //use this to ensure we do not loop through atoms again touched[x_y]=1;

Build_Puzzle(document.getElementById("input_area").value);
  
function X_Y_To_String(x,y){
return x.toString()+'_'+y.toString();  
}
  
function String_To_X_Y( x_y ){//returns [x,y] int
var x,y;
[x,y] = x_y.split('_');  
return [parseInt(x) , parseInt(y)];  
}
  
function Build_Puzzle(input_string){ //build display board and board objects
board = {};
board.x_me=0;
board.y_me=0; 
board.width = 0;
board.height = 0; 
move = {};
atom_intended_move = {};
previous_board = [];
touched = {};
                    
input_string = input_string.trim();
var lines = input_string.split("\n"); //1st line is my position
x_y_me = lines.shift();
[board.x_me,board.y_me] = String_To_X_Y(x_y_me);
var y = -1;
var board_string = '';
for(var line of lines){
  y++;
  if(y > board.height) { board.height = y; }
  var x = -1;
  for(var letter of line){
    x++;
    if(x > board.width) { board.width = x; }
    var state = State(x,y);
    var x_y = X_Y_To_String(x,y);    
    if(!validate_board_pos[state].includes(letter)){
       error_msg = error_msg + 'Letter ' + letter + ' not allowed in ' + state + ' position + ' + x_y + '. ';
       //alert(error_msg);
       console.log(error_msg);
    }  
    board_string = board_string + Next_Div(x_y , state); //create the div board
    
    //create the board[x_y] objects
    if(empty_chars.includes(letter)) { //0 indicates empty only 
      board[x_y] = new Empty(x,y);
    } 
    if( bond_chars.includes(letter) ) {
      board[x_y] = new Bond(x,y,letter);
    }
    if( wall_chars.includes(letter) ) {
      board[x_y] = new Wall(x,y,letter);
    }
    if( atom_chars.includes(letter) ) {
      board[x_y] = new Atom(x,y,letter);
    } 
    if( modifier_chars.includes(letter) ) { // + - .
      board[x_y] = new Bond_Modifier(x,y,letter);
    }
  }
board_string = board_string + '<br>';
}
document.getElementById("board").innerHTML = board_string;
if(error_msg !== ''){
 alert(error_msg); 
}
Display_Objects();
}
 
function Atom(x , y , letter){ // Constructor
  this.is_a = 'atom';
  this.x = x;
  this.y = y;
  this.letter = letter; //H, h, O, N, C
  this.valence = {'h': 0 , 'H':1 , 'O':2 , 'N':3 , 'C':4}[letter]; //set on create based on letter
  //this.free_valence = this.valence;
  
  //this.Can_I_Move = function(x,y,dx,dy){ //also transfers force
  this.Can_I_Move = function(NEWS){ //also transfers force
    var dx = direction[NEWS].x;
    var dy = direction[NEWS].y;
    var x_y = this.x.toString() + '_' + this.y.toString(); 
    var all_news = Get_NEWS(this.x,this.y);
    var x_y_half_step = all_news[NEWS].x_y_half_step;
    var x_y_full_step =  all_news[NEWS].x_y_full_step;
    
    //1. check for a wall hit
    if(board[x_y_full_step].is_a === 'wall') {return false;} 
    touched[x_y]=1; //set this touched{x_y}=1 so we don't recurse into this atom again and create infite loops
    //2. check to see if something else is moving to the same location
    if(atom_intended_move[x_y_full_step]) {return false;} //and atom is already moving here. fail  
    //3. state atom's intention of moving here 
    atom_intended_move[x_y_full_step] = 1; //used to ensure 2 atoms are not fighting to move to same space
    
    //4. see if non bonded atom,not touched, is in our way, and see if it can move
    if(board[x_y_half_step].is_a !== 'bond'){//no bond in our way
      if(board[x_y_full_step].is_a === 'atom'){//atom in our way
        if(touched[x_y_full_step] !== 1){//hasn't been touched
          if(!board[x_y_full_step].Can_I_Move(NEWS)){return false;}
        }       
      }    
    }
    
    //see if bonds (not touched) can move 
    var all_news =  Get_NEWS(this.x,this.y) 
    for(var key in all_news){
      let x_y_half_step = all_news[key].x_y_half_step;
      let receiving_atom = all_news[key].x_y_full_step; //is where receiving atom is
      if(board[x_y_half_step].is_a === 'bond'){//a bond can only be crossed once, so no need to chech if touched
        if(!board[x_y_half_step].Can_I_Move(NEWS , receiving_atom)){return false;}
        //
      }
    }
        
    //if here, all downstream tests are good to move. but this does not mean that the move will not fail. 
    this.x = this.x + dx + dx;
    this.y = this.y + dy + dy;
    move[x_y] = x_y_full_step; //used to move atoms if we are good to go
    return true; 
    }; 

  this.Join_To_Free_Atoms = function(){
    //Return_Free_Valence of this atom
    var free_valence = this.Return_Free_Valence();
    //for adjacent atoms in direction with no bond && adjacent atoms with free valence , create a bond until my free_valence === 0
    //for(var key in direction){
    var all_news =  Get_NEWS(this.x,this.y) 
    for(var key in all_news){
      if(free_valence <= 0){return;}
      var x_half_step = all_news[key].x_half_step;
      var y_half_step = all_news[key].y_half_step;
      var x_y_half_step = all_news[key].x_y_half_step;
      var x_y_full_step = all_news[key].x_y_full_step;
      if(board[x_y_full_step].is_a === 'atom'){
        if(board[x_y_full_step].Return_Free_Valence() > 0){
          if(board[x_y_half_step].is_a === 'empty'){
          board[x_y_half_step] = new Bond(x_half_step,y_half_step,'1'); //add a bond
          free_valence--;
          }
        }
      }
    }    
  };
  
  this.Return_Free_Valence  = function(){
    //look in all directions and calculate  
    var sum = 0;
    var free_valence;
    var x_test;
    var y_test;
    var all_news =  Get_NEWS(this.x,this.y) 
    for(var key in all_news){
      var x_y = all_news[key].x_y_half_step;
      if(board[x_y].is_a === 'bond'){
        sum = sum + board[x_y].value;  
      }
    }
    free_valence = this.valence - sum; 
    if(free_valence < 0){
      console.log('Impossible free_valence at ' + x + '_' + y);
    }
    return free_valence;
  };
  
  return this; //return constructor
}
   
function Bond(x,y,letter){
  this.is_a = 'bond';
  this.x = x;
  this.y = y;
  this.letter = letter;
  this.value = parseInt(letter); 
  
  this.Can_I_Move = function(NEWS , receiving_atom){ //also transfers force
    var dx = direction[NEWS].x;
    var dy = direction[NEWS].y;
    var x_y = this.x.toString() + '_' + this.y.toString(); 
    var all_news = Get_NEWS(this.x,this.y);
    var x_y_half_step = all_news[NEWS].x_y_half_step;
    var x_y_full_step =  all_news[NEWS].x_y_full_step;
    touched[x_y]=1; //don't use this for bonds 
    //1.is there a bond_modifyer in the path - y ?
    if(board[x_y_half_step].is_a === 'bond_modifyer'){
      
    }
    //if receiving atom already touched just return true
    if(touched[receiving_atom]){ return true; }
    
    //transmit move / force to receiving atom
    if(!board[receiving_atom].Can_I_Move(NEWS)){return false;}
    
    //move bond
    this.x = this.x + dx + dx;
    this.y = this.y + dy + dy;
    move[x_y] = x_y_full_step; //used to move atoms if we are good to go
    return true;     
  }
   
  return this;
}
  
function Empty(x,y,letter){
  this.is_a = 'empty';
  this.letter = letter;
  this.x = x;
  this.y = y; 
  return this;
}
  
function Wall(x,y,letter){
  this.is_a = 'wall';
  this.x = x;
  this.y = y;
  this.letter = letter;  
  return this;
}
  
function Bond_Modifier(x,y,letter){
  this.is_a = 'bond_modifier';
  this.x = x;
  this.y = y;
  this.letter = letter;  
  return this;
  //- reduce bond by one
  //+ increase bond by one if joining atoms hav free valences
  // . if a bond hits it, the force transmitted by the bond will change to pull the receiving atom in the direction of the transmitting atom, the bond will move to 
}
  
function State(x,y){
var x_odd = x%2;
var y_odd = y%2;
if ( x_odd && y_odd ){return 'hyperspace';}
if ( !x_odd && !y_odd ){return 'vacuum';}
if ( x_odd && !y_odd ){return 'bond_vert';}
if ( !x_odd && y_odd ){return 'bond_horiz';}
}
  
function Next_Div(x_y , state){
return '<div id=' + x_y + ' class=' + state + '>&nbsp;</div>';  
}
   
function Display_Objects(){
  for(var y = 0 ; y <= board.height ; y++){
    for(var x = 0 ; x <= board.width ; x++){
      var x_y = X_Y_To_String(x,y);
      var element = document.getElementById(x_y);
      if(typeof board[x_y] === 'undefined'){
        continue;
      }
      if(board[x_y].is_a === 'empty'){
        element.innerHTML = '&nbsp;';
        element.classList.remove("me");
      }
      if(board[x_y].is_a === 'wall'){
       element.innerHTML = board[x_y].letter;
      }
      if(board[x_y].is_a === 'atom'){
        element.innerHTML = board[x_y].letter;
        if( (x === board.x_me) && (y === board.y_me) ){element.classList.add("me");}
        else{
          element.classList.remove("me");
        }
      }
      if(board[x_y].is_a === 'bond'){
        element.innerHTML = board[x_y].letter;
      }
      if(board[x_y].is_a === 'bond_modifier'){
        element.innerHTML = board[x_y].letter;
      }
          
    }
  }
}

function Key_Input(keyCode)
{ 
if(document.activeElement === document.getElementById('input_area')){
  return;
}
  
if (keyCode == 82){ //r 82
  while(previous_board.length > 0){
    Set_Board( previous_board.pop() );
    Display_Objects(); 
  }
  return;
}
  
if (keyCode == 90){ //z:undo
  if( previous_board.length > 0){
    Set_Board( previous_board.pop() );
    Display_Objects(); 
    return; //do not hit move routine
    }
}
 
var move_key_pressed = false;
var NEWS;
if (keyCode == 37){ //left 
  NEWS = 'W';
  move_key_pressed = true;
}
  
if (keyCode == 38){ //up
  NEWS = 'N';
  move_key_pressed = true;
}
  
if (keyCode == 39){ //right
  NEWS = 'E';
  move_key_pressed = true;
}
  
if (keyCode == 40){ //down
  NEWS = 'S';
  move_key_pressed = true;
}
  
if(move_key_pressed){  
//clear and get ready for another move
move = {};
atom_intended_move = {};
touched = {};
//if ( board[board.x_me+'_'+board.y_me].Can_I_Move(board.x_me,board.y_me,direction[NEWS].x , direction[NEWS].y) ){  
if ( board[board.x_me+'_'+board.y_me].Can_I_Move(NEWS) ){  
  //move[x_y] = 'x_y_new'
  //so for all premoves (keys) copy all the references temp[x_y]  = board[x_y] then board[x_y] = new empty(x,y) 
  //then for each x_y key copy to new position board[x_y_new] = temp[x_y]
  previous_board.push(JSON.stringify(board)); //save new board state
  //the_last_board = JSON.stringify(board);//store this move for undo before we move
  var temp = {};
  for(var key in move) { //save temp reference for all moving board objects. then remove the board references (set to empty)
    temp[key] = board[key];
    board[key] = new Empty(String_To_X_Y(key));
  }
  for(var key in move){ //now set all moved board references
    board[move[key]] = temp[key];
  }
  //move me
  x_y_me = move[board.x_me+'_'+board.y_me];
  [board.x_me,board.y_me] = String_To_X_Y(x_y_me);
  //Display_Objects();
  }
else{
    //nothing has moved, but reset board objects with last board state as some x,y may be wrong. recursive fail routine will miss some objects 
    Set_Board( previous_board[previous_board.length-1] );
    return; //skip next steps!
  }

}
  
//we may have moved all atoms. for every atom, check for atoms that can bond
for(var key in board){
  if(board[key].is_a === 'atom'){
    board[key].Join_To_Free_Atoms();
  }
}

//previous_board.push(JSON.stringify(board)); //save new board state
  
Display_Objects();
  
//esc : 27
}	
  
function Set_Board(json_string){
  var new_board = JSON.parse(json_string);
  board.x_me = new_board.x_me;
  board.y_me = new_board.y_me;
  board.width = new_board.width;
  board.height = new_board.height;
  for(var key in new_board){
    var x , y;
    [x,y] = String_To_X_Y(key);
    if(new_board[key].is_a === 'wall'){board[key] = new Wall(x,y,new_board[key].letter);}
    if(new_board[key].is_a === 'empty'){board[key] = new Empty(x,y,new_board[key].letter);}
    if(new_board[key].is_a === 'bond'){board[key] = new Bond(x,y,new_board[key].letter);}
    if(new_board[key].is_a === 'atom'){board[key] = new Atom(x,y,new_board[key].letter);}    
  }
}

//What would a win look like and how do we test for it?

//all atom forces must be transmitted in order from source to receiver 

</script>
</body>
</html>
